---
title: RFK | Software | PyEnchant
---

<h1>PyEnchant Tutorial</h1>


<p>This page offers a quick tutorial to get up and running with the PyEnchant
package. If you are already familiar with the basics of installing
and using Python packages, you may prefer to simply browse the <a href="./api/enchant.html">PyEnchant API listing</a>.</p>


<h2>Table of Contents</h2>

<ul class="toc">
  <li><a href="#installation">Installing PyEnchant</a></li>
  <ul class="toc">
    <li><a href="#installation-windows">Windows Users</a></li>
    <li><a href="#installation-osx">Mac OS X Users</a></li>
    <li><a href="#installation-other">Other Platforms</a></li>
    <li><a href="#installation-dicts">Adding Language Dictionaries</a></li>
    <ul class="toc">
      <li><a href="#installation-dicts-windows">Windows Users</a></li>
      <li><a href="#installation-dicts-osx">Mac OS X Users</a></li>
      <li><a href="#installation-dicts-other">Other Platforms</a></li>
    </ul>
  </ul>
  <li><a href="#basics">Basic PyEnchant Usage</a></li>
  <ul class="toc">
    <li><a href="#basics-dict">Creating and Using Dictionary Objects</a></li>
    <li><a href="#basics-pwl">Personal Word Lists</a></li>
    <li><a href="#basics-checker">Checking entire blocks of text</a></li>
    <li><a href="#basics-wx">wxSpellCheckerDialog</a></li>
    <li><a href="#basics-cmdline">CmdLineChecker</a></li>
    <li><a href="#basics-tokenize">Tokenization: splitting text into words</a></li>
    <li><a href="#basics-chunkers">Chunkers</a></li>
    <li><a href="#basics-filters">Filters</a></li>
  </ul>
  <li><a href="#advanced">Advanced PyEnchant Usage</a></li>
  <ul class="toc">
    <li><a href="#advanced-providers">Providers</a></li>
    <li><a href="#advanced-brokers">Brokers</a></li>
    <ul class="toc">
      <li><a href="#advanced-brokers-default">The Default Broker</a></li>
      <li><a href="#advanced-brokers-ordering">Provider Ordering</a></li>
    </ul>
    <li><a href="#advanced-tokenize">Extending enchant.tokenize</a></li>
  </ul>
  <li><a href="#packaging">PyEnchant and other programs</a></li>
  <ul class="toc">
    <li><a href="#packaging-py2exe">Packaging PyEnchant with py2exe</a></li>
  </ul>
</ul>


<a name="installation"><h2>Installing PyEnchant</h2></a>

<a name="installation-windows"><h3>Windows Users</h3></a>

<p>
Download the pre-built Windows installer from the <a href="./download.html">download page</a> and run it to install PyEnchant. It will place the
'enchant' module in your Python site-packages directory.</p>

<p>As of PyEnchant 1.5.0 there is a single installer for all versions of Python.
It has been successfully testing with Python 2.5 and Python 2.6.</p>

<a name="installation-osx"><h3>Mac OS X Users</h3></a>

<p>
Download the pre-built OSX installer from the <a href="./download.html">download page</a> and execute it in the finder.  It will place the
'enchant' module in your Python site-packages directory.</p>

<p>There are also eggs available for users who prefer them.</p>


<a name="installation-other"><h3>Other Platforms</h3></a>

<p>Your operating system distributor may provide PyEnchant via their
own packaging system - please check there first.</p>

<ul>
<li><b>Debian and Ubuntu Users</b>: pyenchant is available through apt-get</li>
<li><b>Gentoo Users</b>: pyenchant is available in portage</li>
</ul>

<p>If a package is not provided by your operating system distributor, you will
need to install from source.</p>

<p>If you have an active internet connection, the
following procedure will automatically download any additional files required 
to complete the installation.  If not, you need to ensure that you have
the latest version of setuptools installed.  The <a href="http://peak.telecommunity.com/DevCenter/EasyInstall#installation-instructions">Easy Install
 Setup Guide</a>  might help you here.</p>

<ol>
<li>Install Enchant as described on the <a href="http://www.abisource.com/enchant/">enchant website</a>.</li>
<li>Install PyEnchant using the standard Python setuptools procedure:</li>
  <ol>
  <li><a href="./download.html">Download</a> and untar the source files.</li>
  <li>Enter the distribution directory, which contains the file 'setup.py'.</li> 
  <li>Execute the command:{% syntax sh %}python setup.py install{% endsyntax %}<p></li>
  <li>Please refer to the <a href="http://docs.python.org/inst/inst.html">distutils documentation</a> and the following <a href="http://peak.telecommunity.com/DevCenter/setuptools#what-your-users-should-know">notes on setuptools</a> for help on installing Python modules in this manner.
  </ol>
</ol>

<a name="installation-dicts"><h3>Adding Language Dictionaries</h3></a>

<p>By default, PyEnchant on the Windows platform ships with a limited number of
language dictionaries:</p>

<ul>
<li>en_GB: British English</li>
<li>en_US: American English</li>
<li>de_DE: German</li>
<li>fr_FR: French</li>
</ul>

<p>For users of other platforms, the available dictionaries will depend on your
installation of Enchant.  If the language you wish to use is not available,
you will need to install additional dictionaries.</p>

<a name="installation-dicts-windows"<h4>Windows Users</h4></a>

<p>PyEnchant can use dictionaries from the OpenOffice.org project.  Locate the
appropriate file on their dictionary download page at
<a href="http://wiki.services.openoffice.org/wiki/Dictionaries">http://wiki.services.openoffice.org/wiki/Dictionaries</a>.</p>

<p>The download will be a zip file containing the necessary dictionary files.
The contents of this zip file must be extracted into the directory
"Lib/site-packages/enchant/share/enchant/myspell" inside your Python
installation
directory.  For example, if Python is installed into "C:/Python23" then
extract the dictionary files into
"C:/Python23/Lib/site-packages/enchant/share/enchant/myspell".</p>

<p>Note that despite the legacy name "myspell", the latest version of PyEnchant
actually uses Hunspell and should be compatible with the latest
Hunspell-specific dictionaries.</p>

<a name="installation-dicts-osx"<h4>Mac OS X Users</h4></a>

<p>PyEnchant can use dictionaries from the OpenOffice.org project.  Locate the
appropriate file on their dictionary download page at
<a href="http://wiki.services.openoffice.org/wiki/Dictionaries">http://wiki.services.openoffice.org/wiki/Dictionaries</a>.</p>

<p>The download will be a zip file containing the necessary dictionary files.
The contents of this zip file must be extracted into the directory
"site-packages/enchant/share/enchant/myspell" inside your Python
installation
directory.  For example, if Python is installed into "/Library/Frameworks/Python.framework/Versions/2.6" then
extract the dictionary files into
"/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/site-packages/enchant/share/enchant/myspell".</p>

<p>Note that despite the legacy name "myspell", the latest version of PyEnchant
actually uses Hunspell and should be compatible with the latest
Hunspell-specific dictionaries.</p>


<a name="installation-dicts-other"><h4>Other Platforms</h4></a>

<p>The installation of additional dictionaries is the responsibility of
the underlying Enchant library.  Please consult your operating system
vendor or the <a href="http://www.abisource.com/enchant/">Enchant website</a> for more details.</p>


<a name="basics"><h2>Basic PyEnchant Usage</h2></a>

<p>Once installed, PyEnchant's functionality is available in the &quot;enchant&quot; module.</p>

<a name="basics-dict"><h3>Creating and Using Dictionary Objects</h3></a>

<p>The most important object in the PyEnchant module is the <a href="api/enchant.html#Dict" class="api-ref">Dict</a>
object, which represents a dictionary. These objects are used to check
the spelling of words and to get suggestions for misspelled words.
The following shows how to construct a simple Dict and use it to check
some words:</p>

{% syntax python %}>>> import enchant
>>> d = enchant.Dict("en_US")
>>> d.check("Hello")
True
>>> d.check("Helo")
False
>>>
{% endsyntax %}

<p>Dictionaries are created using a <i>language tag</i> which
specifies the language to be checked - in this case, &quot;en_US&quot;
signifies American English.  If the language tag is not specified, an
attempt is made to determine the language currently in use.  This is
not always possible, in which case an Error is raised.</p>

<p>When the current language can be determined, it operates as follows:</p>


{% syntax python %}>>> d = enchant.Dict()
>>> d.tag
'en_AU'
>>> print d.tag
en_AU
>>>
{% endsyntax %}

<p>Of course, this may still fail if the appropriate dictionary is not available.
If it cannot be determined, the behavior is as follows:</p>

{% syntax python %}>>> d = enchant.Dict()
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
  File "enchant/__init__.py", line 467, in __init__
    raise Error(err)
enchant.Error: No tag specified and default language could not be determined.
>>>
{% endsyntax %}

<p>There are several top-level functions in
the enchant module which can be used to deal with dictionaries:</p>

<ul>
<li><a href="./api/enchant.html#-dict_exists" class="api-ref">dict_exists</a>: Check whether a Dict is available for a given language</li>
<li><a href="./api/enchant.html#-request_dict" class="api-ref">request_dict</a>: Construct and return a new Dict object</li>
<li><a href="./api/enchant.html#-list_languages" class="api-ref">list_languages</a>: List the languages for which Dicts are available</li>
</ul>

{% syntax python %}>>> enchant.dict_exists("fake")
False
>>> enchant.dict_exists("en_US")
True
>>> d = enchant.request_dict("en_US")
>>> d
<enchant.Dict object at 0x2aaaabdffa50>
>>> enchant.list_languages()
['en', 'en_CA', 'en_GB', 'en_US', 'eo', 'fr', 'fr_CH', 'fr_FR']
>>>
{% endsyntax %}

<p>As shown previously, the <a href="./api/enchant.html#Dict-check" class="api-ref">check</a> method of a Dict object
can be used to check whether a word is correctly spelled. To get suggestions
for a misspelled word, use the <a href="./api/enchant.html#Dict-suggest" class="api-ref">suggest</a> method
as shown below:</p>

{% syntax python %}>>> d.suggest("Helo")
['He lo', 'He-lo', 'Hello', 'Helot', 'Help', 'Halo', 'Hell', 'Held',
'Helm', 'Hero', "He'll"]
>>>
{% endsyntax %}

<p>The suggestions are returned in a list, ordered from most likely replacement
to least likely.</p> 

<p>Once a correction is made to a miss-spelled word, it is often useful to
store this correction in some way for later use.  The Dict object provides
several methods to handle this:</p>

<ul>
<li><a href="./api/enchant.html#Dict-add" class="api-ref">add</a>: store an unrecognised word in the user's personal
dictionary so that it is recognised as correct in the future.</li>
<li><a href="./api/enchant.html#Dict-remove" class="api-ref">remove</a>: store a recognised word in the user's personal
exclude list, so that it is identified as an error in the future.</li>
<li><a href="./api/enchant.html#Dict-add_to_session" class="api-ref">add_to_session</a>:  store an unrecognised word so that it will be
recognised as correct while the Dict object is still in use.</li>
<li><a href="./api/enchant.html#Dict-store_replacement" class="api-ref">store_replacement</a>: note that one word was used to replace another,
meaning that it will appear higher in the list of suggestions in the future.</li>
</ul>

<a name="basics-pwl"><h3>Personal Word Lists</h3></a>

<p>Dict objects can also be used to check words against a custom list of
correctly-spelled words known as a <i>Personal Word List</i>.  This is
simply a file listing the words to be considered, one word per line.
The following example creates a Dict object for the personal word list
stored in "mywords.txt":</p>

{% syntax python %}>>> pwl = enchant.request_pwl_dict("mywords.txt")
>>>
{% endsyntax %}

<p>The personal word list Dict object can be used in the same way as
Dict objects which reference a language dictionary.  When the object's
<a href="./api/enchant.html#Dict-add" class="api-ref">add</a> method is called, new entries will be appended to
the bottom of the file.</p>

<p>PyEnchant also provides the class <a href="./api/enchant.html#DictWithPWL" class="api-ref">DictWithPWL</a> which can be used
to combine a language dictionary and a personal word list file:</p>

{% syntax python %}>>> d2 = enchant.DictWithPWL("en_US","mywords.txt")
>>> d2.check("Hello")
True
>>>
{% endsyntax %}

<a name="basics-checker"><h3>Checking entire blocks of text</h3></a>

<p>While the enchant.Dict objects are useful for spellchecking individual
words, they cannot be used directly to check, for example, an entire
paragraph.  The module <a href="./api/enchant.checker.html" class="api-ref">enchant.checker</a> provides a class
<a href="./api/enchant.checker.html#SpellChecker" class="api-ref">SpellChecker</a> which is designed to handle this task.</p>

<p>SpellChecker objects are created in the same way as Dict objects -
by passing a language tag to the constructor.  The <a href="./api/enchant.checker.html#SpellChecker-set_text" class="api-ref">set_text</a> method
is used to set the text which is to be checked.  Once this is done,
the SpellChecker object can be used as an iterator over the spelling
mistakes in the text.  This is best illustrated by a simple example.
The following code will print out the errors encountered in a string:</p>

{% syntax python %}>>> from enchant.checker import SpellChecker
>>> chkr = SpellChecker("en_US")
>>> chkr.set_text("This is sme sample txt with erors.")
>>> for err in chkr:
...   print "ERROR:", err.word
...
ERROR: sme
ERROR: txt
ERROR: erors
>>>
{% endsyntax %}

<p>The SpellChecker can use <a href="#Filters">filters</a>
 to ignore certain word forms, by
passing a list of filters in as a keyword argument:</p>

{% syntax python %}>>> from enchant.checker import SpellChecker
>>> from enchant.tokenize import EmailFilter, URLFilter
>>> chkr = SpellChecker("en_US",filters=[EmailFilter,URLFilter])
>>>
{% endsyntax %}

<p>The iterator paradigm can be used to implement a wide variety of spellchecking
functionality.  As examples of how this can be done, PyEnchant provides
a wxPython-based spellchecking dialog and a command-line spellchecking
program.  While intended mainly as functionality demos, they are also
quite useful in their own right.</p>

<a name="basics-wx"><h3>wxSpellCheckerDialog</h3></a>

<img style="border: 1px solid black; float: right; margin-left: 3em; margin-bottom: 1em; margin-right: 3em;" src="wxSpellCheckerDialog.png" />

<p>The module <a href="./api/enchant.checker.wxSpellCheckerDialog.html" class="api-ref">enchant.checker.wxSpellCheckerDialog</a> provides the class
<a href="./api/enchant.checker.wxSpellCheckerDialog.html#wxSpellCheckerDialog" class="api-ref">wxSpellCheckerDialog</a> which can be used to interactively check
the spelling of some text.  The code below shows how to create and use
such a dialog from within a wxPython application.</p>
<p>It will pop up a simple spellchecking dialog like the one shown here.
Each spelling error is highlighted in turn, with the buttons offering a range
of options for how to deal with the error:</p>

<ul>
<li><b>Ignore</b>: ignore the current occurence of the word</li>
<li><b>Ignore All</b>: ignore the current and all future occurances of the word</li>
<li><b>Replace</b>: replace the current occurence with the corrected word</li>
<li><b>Replace All</b>: replace the current and all future occurences with
the corrected word</li>
<li><b>Add</b>: add the word to the user's personal dictionary</li>
</ul>

<p style="clear: both;" class="code">{% syntax python %}>>> import wx
>>> from enchant.checker import SpellChecker
>>> from enchant.checker.wxSpellCheckerDialog import wxSpellCheckerDialog
>>> 
>>> app = wx.PySimpleApp()
>>> text = "This is sme text with a fw speling errors in it. Here are a fw more to tst it ut."
>>> dlg = wxSpellCheckerDialog(None,-1,"")
>>> chkr = SpellChecker("en_US",text)
>>> dlg.SetSpellChecker(chkr)
>>> dlg.Show()
>>> app.MainLoop()
{% endsyntax %}

<a name="basics-cmdline"><h3>CmdLineChecker</h3></a>

<p>The module <a href="./api/enchant.checker.CmdLineChecker.html" class="api-ref">enchant.checker.CmdLineChecker</a> provides the class
<a href="./api/enchant.checker.CmdLineChecker.html#CmdLineChecker" class="api-ref">CmdLineChecker</a> which can be used to interactively check
the spelling of some text.  It uses standard input and standard output
to interact with the user through a command-line interface.
The code below shows how to create and use this class from within a python
application, along with a short sample checking session.</p>

{% syntax python %}>>> import enchant
>>> import enchant.checker
>>> from enchant.checker.CmdLineChecker import CmdLineChecker
>>> chkr = enchant.checker.SpellChecker("en_US")
>>> chkr.set_text("this is sme example txt")
>>> cmdln = CmdLineChecker()
>>> cmdln.set_checker(chkr)
>>> cmdln.run()
ERROR: sme
HOW ABOUT: ['some', 'same', 'Sm', 'Ame', 'ME', 'Me', 'SE', 'Se', 'me', 'Esme', 'Mme', 'SSE', 'See',
 'Sue', 'see', 'sue', 'Ste', "Sm's"]
>> help
0..N:    replace with the numbered suggestion
R0..rN:  always replace with the numbered suggestion
i:       ignore this word
I:       always ignore this word
a:       add word to personal dictionary
e:       edit the word
q:       quit checking
h:       print this help message
----------------------------------------------------
HOW ABOUT: ['some', 'same', 'Sm', 'Ame', 'ME', 'Me', 'SE', 'Se', 'me', 'Esme', 'Mme', 'SSE', 'See',
 'Sue', 'see', 'sue', 'Ste', "Sm's"]
>> 0
Replacing 'sme' with 'some'
ERROR: txt
HOW ABOUT: ['text', 'TX', 'ext']
>> i
>>> chkr.get_text()
'this is some example txt'
>>>
{% endsyntax %}

<p>As shown by this simple example, the CmdLineChecker prints each error
it encounters, along with a list of suggested replacements.  The user
enters the desired behavior using short alphanumeric commands, as
explained by the output of the 'help' command.</p>

<a name="basics-tokenize"><h3>Tokenization: splitting text into words</h3></a>

<p>An important task in spellchecking is splitting a body of text up into
its constituative words, each of which is then passed to a Dict object
for checking.  PyEnchant provides the <a href="./api/enchant.tokenize.html" class="api-ref">enchant.tokenize</a> module
to assist with this task.  The purpose of this module is to provide an
appropriate <i>tokenization function</i> which can be used to split
the text.  Usually, all that is required is the <a href="./api/enchant.tokenize.html#-get_tokenizer" class="api-ref">get_tokenizer</a> function:</p>

{% syntax python %}>>> from enchant.tokenize import get_tokenizer
>>> tknzr = get_tokenizer("en_US")
>>> tknzr
<class enchant.tokenize.en.tokenize at 0x2aaaaab531d0>
>>> [w for w in tknzr("this is some simple text")]
[('this', 0), ('is', 5), ('some', 8), ('simple', 13), ('text', 20)]
>>>
{% endsyntax %}

<p>As shown in the example above, the function <a href="./api/enchant.tokenize.html#-get_tokenizer" class="api-ref">get_tokenizer</a> takes a
language tag as input, and returns a tokenization class that is
appropriate for that language.  Instantiating this class with some
text returns an iterator which will yield the words contained in that text.
This is exactly the mechanism that the SpellChecker class uses internally
to split text into a series of words.</p>

<p>The items produced by the tokenizer are tuples of the form (WORD,POS) where
WORD is the word which was found and POS is the position within the
string at which that word begins.</p>

<a name="basics-chunkers"><h3>Chunkers</h3></a>

<p>In many applications, checkable text may be intermingled with some sort of markup (e.g. HTML tags) which does not need to be checked.  To have the tokenizer return only those words that should be checked, it can be augmented with one or more <i>chunkers</i>.</p>

<p>A chunker is simply a special tokenizer function that breaks text up into large chunks rather than individual tokens.  They are typically used by passing a list of chunkers to the <a href="./api/enchant.tokenize.html#-get_tokenizer" class="api-ref">get_tokenizer</a> function:</p>

{% syntax python %}>>> from enchant.tokenize import get_tokenizer, HTMLChunker
>>>
>>> tknzr = get_tokenizer("en_US"])
>>> [w for w in tknzr("this is <span class='important'>really important</span> text")]
[('this', 0), ('is', 5), ('span', 9), ('class', 14), ('important', 21), ('really', 32), ('important', 39), ('span', 50), ('test', 56)]
>>>
>>>
>>> tknzr = get_tokenizer("en_US",chunkers=(HTMLChunker,))
>>> [w for w in tknzr("this is <span class='important'>really important</span> text")]
[('this', 0), ('is', 5), ('really', 32), ('important', 39), ('test', 56)]
{% endsyntax %}

<p>When the HTMLChunker is applied to the tokenizer, the <span> tag and its contents are removed from the list of words.</p>

<p>Currently the only implemented chunker is <a href="./api/enchant.tokenize.html#HTMLChunker" class="api-ref">HTMLChunker</a>.  A chunker for LaTeX documents is in the works.</p>

<a name="basics-filters"><h3>Filters</h3></a>

<p>In many applications, it is common for spellchecking to ignore words
that have a certain form.  For example, when spellchecking an email
it is customary to ignore email addresses and URLs.  This can
be achieved by augmenting the tokenization process with <i>filters</i>.</p>

<p>A filter is simply a wrapper around a tokenizer that can (1) drop certain words
from the stream, and (2) further split words into sub-tokens.  They are typically used by passing a list of filters to the <a href="./api/enchant.tokenize.html#-get_tokenizer" class="api-ref">get_tokenizer</a> function:</p>

{% syntax python %}>>> from enchant.tokenize import get_tokenizer, EmailFilter
>>>
>>> tknzr = get_tokenizer("en_US")
>>> [w for w in tknzr("send an email to fake@example.com please")]
[('send', 0), ('an', 5), ('email', 8), ('to', 14), ('fake@example.com', 17), ('please', 34)]
>>>
>>> tknzr = get_tokenizer("en_US",[EmailFilter])
>>> [w for w in tknzr("send an email to fake@example.com please")]
[('send', 0), ('an', 5), ('email', 8), ('to', 14), ('please', 34)]
>>>
{% endsyntax %}

<p>When the EmailFilter is applied to the tokenizer, the email address is removed
from the list of words.</p>

<p>Currently implemented filters are <a href="./api/enchant.tokenize.html#EmailFilter" class="api-ref">EmailFilter</a>, <a href="./api/enchant.tokenize.html#URLFilter" class="api-ref">URLFilter</a> and <a href="./api/enchant.tokenize.html#WikiWordFilter" class="api-ref">WikiWordFilter</a>.</p>

<a name="advanced"><h2>Advanced PyEnchant Usage</h2></a>

<a name="advanced-providers"><h3>Providers</h3></a>

<p>The underlying programming model provided by the Enchant library
is based on the notion of <i>Providers</i>.  A provider is a piece of
code that provides spell-checking services which Enchant can use to
perform its work.  Different providers exist for performing spellchecking
using different frameworks - for example there is an
<a href="http://aspell.sourceforge.net/">aspell</a> provider and a
<a href="http://lingucomponent.openoffice.org/">MySpell</a> provider.</p>

<p>In this way, enchant forms a "wrapper" around existing spellchecking tools
in order to provide a common programming interface.</p>

<p>The provider which is managing a particular Dict object can be determined
by accessing its <a href="./api/enchant.html#Dict" class="api-ref">provider</a> attribute.
This is a <a href="./api/enchant.html#ProviderDesc" class="api-ref">ProviderDesc</a> object
with the properties <i>name</i>, <i>desc</i> and <i>file</i>.</p>

{% syntax python %}>>> d = enchant.Dict("en_US")
>>> d.provider
<Enchant: Aspell Provider>
>>> d.provider.name
u'aspell'
>>> d.provider.desc
u'Aspell Provider'
>>> d.provider.file
u'/usr/lib64/enchant/libenchant_aspell.so'
>>>
{% endsyntax %}

<a name="advanced-brokers"><h3>Brokers</h3></a>

<p>The details of which provider is used to create a particular dictionary
are managed by a <a href="./api/enchant.html#Broker" class="api-ref">Broker</a> object.  Such objects have methods for
creating dictionaries and checking whether a particular dictionary
exists, as shown in the example below.</p>

{% syntax python %}>>> b = enchant.Broker()
>>> b
<enchant.Broker object at 0x2aaaabdff810>
>>> b.dict_exists("en_US")
True
>>> b.dict_exists("fake")
False
>>> b.list_languages()
['en', 'en_CA', 'en_GB', 'en_US', 'eo', 'fr', 'fr_CH', 'fr_FR']
>>> d = b.request_dict("en_US")
>>> d
<enchant.Dict object at 0x2aaaabdff8d0>
>>>
{% endsyntax %}

<p>Brokers also have the method <a href="./api/enchant.html#Broker-describe" class="api-ref">describe</a> which determines which providers
are available, and the method <a href="./api/enchant.html#Broker-list_dicts" class="api-ref">list_dicts</a> which lists the dictionaries
available through each provider.</p>

{% syntax python %}>>> b = enchant.Broker()
>>> b.describe()
[<Enchant: Aspell Provider>, <Enchant: Myspell Provider>, <Enchant: Ispell Provider>]
>>> b.list_dicts()
[('en', <Enchant: Aspell Provider>), ('en_CA', <Enchant: Aspell Provider>), ('en_GB', <Enchant: Aspell Provider>),
 ('en_US', <Enchant: Aspell Provider>), ('eo', <Enchant: Aspell Provider>), ('fr', <Enchant: Aspell Provider>),
 ('fr_CH', <Enchant: Aspell Provider>), ('fr_FR', <Enchant: Aspell Provider>)]
>>>
{% endsyntax %}

<a name="advanced-brokers-default"><h4>The Default Broker</h4></a>

<p>In normal use, the functionality provided by brokers is not useful to the
programmer.  To make the programmer's job easier, PyEnchant creates a default
Broker object and uses it whenever one is not explicitly given.  For example,
the default broker is used when creating dictionary objects directly.  This
object is available as <a href="./api/enchant.html" class="api-ref">enchant._broker</a>.</p>

{% syntax python %}>>> enchant._broker
<enchant.Broker object at 0x2aaaabdff590>
>>> d = enchant.Dict("en_US")
>>> d._broker
<enchant.Broker object at 0x2aaaabdff590>
>>>
{% endsyntax %}

<p>You may have noticed that the top-level functions provided by the
enchant module (such as <a href="./api/enchant.html#-request_dict" class="api-ref">request_dict</a>, <a href="./api/enchant.html#-dict_exists" class="api-ref">dict_exists</a> and <a href="./api/enchant.html#-list_languages" class="api-ref">list_languages</a>)
match the methods provided by the Broker class.  These functions are in
fact the instance methods of the default Broker object:</p>

{% syntax python %}>>> enchant._broker
<enchant.Broker object at 0x2aaaabdff590>
>>> enchant.request_dict.im_self
<enchant.Broker object at 0x2aaaabdff590>
>>> enchant.dict_exists.im_self
<enchant.Broker object at 0x2aaaabdff590>
>>>
{% endsyntax %}

<a name="advanced-brokers-ordering"><h4>Provider Ordering</h4></a>

<p>Which provider is used for which language is determined by the provider
ordering of the Broker.  This can be altered using the <a href="./api/enchant.html#Broker-set_ordering" class="api-ref">set_ordering</a>
method. This method accepts a language tag and a comma-seperated list
of provider names in the order that they should be checked.  A language
tag of "*" means that the ordering should be the default for all languages
where an explicit ordering has not been given.</p>

<p>The following
example states that for American English the MySpell provider should be tried
first, followed by the aspell provider.  For all other languages, the
ordering is reversed.</p>

{% syntax python %}>>> b = enchant.Broker()
>>> b.set_ordering("en_US","myspell,aspell")
>>> b.set_ordering("*","aspell,myspell")
>>> b.request_dict("en_US").provider
<Enchant: Myspell Provider>
>>> b.request_dict("en_GB").provider
<Enchant: Aspell Provider>
>>>
{% endsyntax %}

<p>The user can also set their prefered ordering using enchant configuration
files.  For this reason, application programmers are discouraged from
explicitly setting an ordering unless there is a compelling reason to do so.</p>

<a name="advanced-tokenize"><h3>Extending enchant.tokenize</h3></a>

<p>As explained above, the module
<a href="./api/enchant.tokenize.html" class="api-ref">enchant.tokenize</a> provides the ability to split text into its
component words.  The current implementation is based only on the rules
for the English language, and so might not be completely suitable for
your language of choice.  Fortunately, it is straightforward to extend
the functionality of this module.</p>

<p>To implement a new tokenization routine for the language TAG, simply
create a class/function "tokenize" within the module "enchant.tokenize.TAG".
This function will automatically be detected by the module's <a href="./api/enchant.tokenize.html#-get_tokenizer" class="api-ref">get_tokenizer</a>
function and used when appropriate.  The easiest way to accomplish this
is to copy the module "enchant.tokenize.en" and modify it to suit your
needs.</p>

<p>The author would be very grateful for tokenization routines for languages
other than English which can be incorporated back into the main PyEnchant
distribution.</p>

<a name="packaging"><h2>PyEnchant and other programs</h2></a>

<a name="packaging-py2exe"><h3>Packaging PyEnchant with py2exe</h3></a>

<p>PyEnchant depends on a large number of auxilliary files such as plugin
libraries, dictionary files, etc.  While py2exe does an excellent job of
detecting static file dependencies, it cannot detect these files which are
located at runtime.</p>

<p>To successfully package an application that uses PyEnchant, these auxilliary
files must be explicitly included in the "data_files" argument to the
setup function.  The function <a href="./api/enchant.utils.html#-win32_data_files" class="api-ref">enchant.utils.win32_data_files</a>
returns a list of files which can be used for this purpose.</p>

