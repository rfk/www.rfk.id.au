---
title: >
 More Django Paranoia
slug: more-django-paranoia
created: !!timestamp '2009-08-16 13:21:50.599445'
modified: !!timestamp '2009-08-16 13:32:14.547636'
tags: 
    - django
---

{% mark excerpt %}<p>As Ryan <a href="http://www.rfk.id.au/blog/entry/announcing-django-paranoid-sessions#comment102">pointed out</a> in response to my previous <a href="http://www.rfk.id.au/blog/entry/announcing-django-paranoid-sessions">post on django-paranoid-sessions</a>, the only way to truly prevent sniffing or man-in-the-middle attacks is to operate over a <a href="http://en.wikipedia.org/wiki/HTTP_Secure">secure connection</a>.   Fair enough, but HTTPS <a href="http://stackoverflow.com/questions/149274/http-vs-https-performance">ain't free</a>.  The general consensus seems to be that a secure connection is too much overhead for anything but the high-value or high-risk sections of your website (login submissions, payment processing, nuclear launch codes, etc).</p>

<p>Ideally, it should be possible to place selected sections of your website behind a secure connection and gain added attack-resistance for those sections, while still sharing session data with the rest of the site.  Using a recommendation from the <a href="http://www.owasp.org/index.php/Session_Management#Protect_Session_Identifiers">OWASP session management guide</a>, the latest release of <a href="http://pypi.python.org/pypi/django-paranoid-sessions/">django-paranoid-sessions</a> now lets you do exactly that.</p>

<p>The idea is to maintain a second randomly-generated session key that is only sent when the client connects over a secure channel.  Unencrypted requests within your session are oblivious to the second key, but if a secure request doesn't provide <i>both</i> valid session keys then it is rejected.  You can think of this extra key as a second "security enhanced" session that transparently piggybacks on top of the standard session data.</p>{% endmark %}

<p>Suppose an attacker is able to sniff your unencrypted requests, obtain your primary session key, and overcome any <a href="http://www.rfk.id.au/blog/entry/announcing-django-paranoid-sessions">fingerprinting or nonce-related roadblocks</a>.  They are then able to impersonate you in any <i>unencrypted</i> request to the server.  But since the second session key is only ever sent on a secure channel, it cannot be sniffed and the attacker cannot obtain enough information to impersonate you in a secure request.  By enforcing that high-value or high-risk actions on your site can only be performed over a secure connection, you get resistance to sniffing or man-in-the-middle attacks without the overhead of serving the whole site over HTTPS.</p>

<p>As another little bonus, the latest version of django-paranoid-sessions also marks its session cookies as being <a href="http://www.owasp.org/index.php/HTTPOnly">httponly</a> to help prevent them being stolen through cross-site scripting attacks.  Unfortunately this is only available when running on Python 2.6 or later, since it must be supported by the underlying cookie-handling library.</p>

<p>Unlike the other security measures employed by this app, I haven't included a setting to disable secure-channel keys or http-only cookies; they're basically cost-free and provide a very real security benefit.  Assuming anyone is actually using this yet, you should definitely <a href="http://pypi.python.org/pypi/django-paranoid-sessions">grab the latest version</a> asap.</p>