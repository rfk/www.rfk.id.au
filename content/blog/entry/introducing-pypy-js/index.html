---
title: >
 Introducing pypy.js
slug: introducing-pypy-js
created: !!timestamp '2013-07-22 23:43:00.000000'
modified: !!timestamp '2013-07-22 23:43:00.000000'
tags: 
    - technology
    - mozilla
    - python
    - javascript

---

{% mark excerpt %}<p>I've been spending a lot of time in javascript land lately.  It's not totally unexpected &ndash; when I first applied for a job with Mozilla, I was warned only semi-jokingly that "they hire all the best python programmers and then force them to write javascript".  I've no particular love or hate for it as a language, but javascript is pretty interesting to me as a <i>platform</i>, as a kind of runs-everywhere lowest-common-demoninator environment that is slowly being molded and coerced into a pretty decent universal runtime.  But if <a href="https://blog.mozilla.org/blog/2012/02/27/mozilla-in-mobile-the-web-is-the-platform/">"The Web is The Platform"</a>, what's a stranded pythonista to do?</p>

<p>Port python to javascript, of course.</p>

<p>This has been done before in a variety of ways.  <a href="http://www.skulpt.org/">Skulpt</a> and <a href="http://www.brython.info/tests/console.html">Brython</a> are very impressive re-implementations of Python on top of JavaScript, including interactive consoles that make for a compelling demo.  <a href="http://pyjs.org/">Pyjamas</a> lets you translate python apps into javascript so they can be run in the browser.  There are <a hef="http://stromberg.dnsalias.org/~strombrg/pybrowser/python-browser.html">many more examples</a> with varying degrees of success and completeness.</p>

<p>I don't want to down-play the phenomenal efforts behind projects like this.  But personally, I'm a little wary of the re-implementation treadmill that they risk being stuck on.  I'd much prefer to leverage the work that's already been done on making a fantastic python interpreter, along with the work that's already been done on making a fantasic javascript runtime, and re-implement as little as possible while gluing them both together.</p>

<p>I've finally taken my first tentative steps down that path, by combining two amazing projects open-source projects: <a href="http://pypy.org">PyPy</a> and <a href="http://emscripten.org">Emscripten</a>.<p>

{% endmark %}

<h3>PyPy</h3>

<p>PyPy advertises itself as <a href="http://pypy.org/">"a fast, compliant alternative implementation of the Python language"</a>, and it has a slick <a href="http://speed.pypy.org/">speedtest site</a> to back up its claims.  Speed is great of course, but what's really interesting are the details of its implementation, which is done in two largely-independent halves.</p>

<p>First, the PyPy interpreter itself is written in a language called <a href="https://rpython.readthedocs.org">RPython</a>, a restricted subset of python that enables efficient ahead-of-time compilation.  This allows for greater ease and flexibility of development than implementing the interpreter directly in C, as is done with the standard interpreter available on <a href="http://python.org">python.org</a>.</p>

<p>Second, there is an <a href="https://rpython.readthedocs.org">rpython compilation toolchain</a> that provides a dazzling array of different methods and options for turning rpython code into an executable.  It can translate RPython into low-level C code for direct compilation, or into higher-level bytecode for the Java and .NET virtual machines.  It can plug in any one of several different memory-management schemes, threading platforms, and a host of other options to customize the final executable.</p>

<p>The rpython toolchain also contains the secret to PyPy's speed: the ability to semi-automatically generate a <a href="https://en.wikipedia.org/wiki/Tracing_JIT">just-in-time compiler</a> for the hot loops of the rpython program.</p>

<p>So in theory, porting python to javascript can be done by just implementing a javascript-emitting backend for the rpython compiler toolchain.</p>

<h3>Emscripten</h3>

<p>Emscripten is <a href="http://emscripten.org/">"an LLVM to JavaScript compiler"</a> that can be used to compile C or C++ programs into javascript.  It is typically used to bring large existing C++ apps to the web, such as games.  It's a terrifyingly beautiful hack, and thanks to recent hot competition in the browser-javascript-performance space, the resulting code can provide quite acceptable performance.</p>

<p>The techniques used by emscripten to map the C programming model onto javascript have recently been formalized in a specification called <a href="http://asmjs.org/">asm.js</a>, a restricted subset of javascript that allows efficient ahead-of-time compilation.  In javascript engines that recognize this subset, the emscripten-compiled code can perform with overhead as low as <a href="http://kripken.github.io/mloc_emscripten_talk/#/27">just two-times slowdown</a> when compared to a native executable.</p>

<p>The potential combination of these two technologies is obvious in theory:  have the rpython toolchain compile things down to C code; compile the C code to javascript using emscripten; party down with python in your browser.</p>

<p>Indeed, emscripten has even been used to compile the standard python interpreter into javascript; this is what powers the python shell at <a href="http://repl.it">repl.it</a>.  But the thought of unlocking the extra speed of PyPy is quite seductive, and the flexibility of the rpython build chain should open up some interesting possibilities.</p>

<h3>A JS backend for RPython</h3>


<p>To the great credit of the PyPy and Emscripten developers, it really was almost as easy in practice as it sounds in theory.  PyPy's rpython toolchain has extension points so you can easily plug in a custom compiler, or indeed a whole new toolchain.  My github fork contains the necessary logic to hook it up to emscripten:</p>

<p>&nbsp;&nbsp;<a href="https://github.com/rfk/pypy">https://github.com/rfk/pypy</a></p>

<p>Emscripten goes out of its way to act like a standard posix build chain, asking only that you replace the usual "gcc" invocation with "emcc".  I had to make a few tweaks to the simulated posix runtime environment, so you'll need to use my fork until these are merged with upstream:</p>

<p>&nbsp;&nbsp;<a href="https://github.com/rfk/emscripten">https://github.com/rfk/emscripten</a></p>

<p>To compile an rpython program into an executable in the "normal" way, you just invoke the rpython interpreter on it.  Here's a simple hello-world example that can be run out-of-the-box from the pypy source repo:</p>

<p class="code">
$> python ./rpython/bin/rpython ./rpython/translator/goal/targetnopstandalone.py
[...lots and lots of compiler output...]
$>
$> ./targetnopstandalone-c 
debug: hello world
$>
</p>

<p>To instead compile the rpython program into javascript, you just need to pass specify the "--backend=js" option.  The resulting javascipt file can be executed with nodejs or the spidermonkey javascript shell:</p>

<p class="code">
$> python ./rpython/bin/rpython --backend=js ./rpython/translator/goal/targetnopstandalone.py
[...lots and lots of compiler output...]
$>
$> node ./targetnopstandalone-js
debug: hello world
$>
</p>

<p>If you've got a few spare hours, you can translate the entire PyPy interpreter like this:</p>

<p class="code">
$> python ./rpython/bin/rpython --backend=js --opt=2 ./pypy/goal/targetpypystandalone.py
[...seriously, this will take forever...]
</p>

XXX TODO: automatically disable modules that don't build correctly in js; the above will not work out of the box

<p>Or you can just grab the end result:  <a href="./pypy.js.gz">pypy.js</a>.</p>

<p>That's 139M of generated javascript that includes a full Python language interpreter, a couple of the more important builtin modules, and the contents of all the .py files from the python standard library.</p>

<p>Naturally there are some caveats here.  The "--opt=2" option disables PyPy's JIT support, since that requires platform-specific support code.  The js backend also automatically disables quite a few builtin modules that don't build cleanly, usually because they have additional C-level dependencies.  I haven't figured out how to give it a proper interactive console yet, and I certainly haven't put a slick browser-based UI on top of it like <a href="http://repl.it">repl.it</a>.</p>

<p>So no, you can't sensibly run this in your browser just yet.  But if you've got a command-line javascript interpreter, you can actually run python commands with this thing by passing them as command-line arguments:</p>

<p class="code">
$> node pypy.js -c 'print "HELLO WORLD"'
debug: WARNING: Library path not found, using compiled-in sys.path.
debug: WARNING: 'sys.prefix' will not be set.
debug: WARNING: Make sure the pypy binary is kept inside its tree of files.
debug: WARNING: It is ok to create a symlink to it from somewhere else.
'import site' failed
HELLO WORLD
$>
</p>

<p>The interpreter generates some generates some debug warnings during startup, because it's a bit confused by the simulated, filesystem-less environment provided by its javascript home.  It also takes a painfully long time to start up, because the files it does need are embedded in the javascript and have to be loaded into memory before execution begins.</p>

<p>Nonetheless, this is a real python interpreter and it can execute real python commands.  To get all that in exchange for a little bit of glue code, seems pretty awesome to me.</p>


<h3>Performance</h3>

<p>The big question of course is, how does it perform?  To analyze this I turned to the python community's most favorite and unscientific benchmark: pystone.  This is a pointless little program that exercises the python interpreter through a number of loops and gives it a speed result in "pystones per second".  Here are the results from the various python interpreters I have sitting on my machine; higher numbers are better:</p>

<table>
<tr><th>Interpreter</th><th>Pystones/sec</th></tr>
<tr><td>pypy.js, on node</td><td>877</td></tr>
<tr><td>pypy.js, on spidermonkey</td><td>7427</td></tr>
<tr><td>native pypy, no JIT</td><td>53418</td></tr>
<tr><td>native cpython</td><td>128205</td></tr>
<tr><td>native pypy, with JIT</td><td>781250</td></tr>
</table>

<p>The slowest result by far was running the compiled pypy.js on the stable release of <a href="http://nodejs.org/">nodejs</a> that I happen to have installed.  This is essentially the base-case performance of the javascript, as this version of node has no particular special handling for the asm.js style of code emitted by emscripten.</p>

<p>Next slowest was running the compiled pypy.js under a nightly build of the <a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey">SpiderMonkey</a> javascript shell.  This is the javascript engine that powers Firefox, and it is able to recognize and optimize the asm.js syntax emitted by emscripten.  As expected, this additional optimization provides a substantial speedup.</p>

<p>Next slowest is a native build PyPy with its JIT features disabled.  Comparing this version to pypy.js gives some idea of the overhead paid when running in javascript versus native code, and we can see that it is around 7 times faster.  That's not even close to the only-two-times-slower results that have been shown on other asm.js-compiled code, but then again, I've put precisely zero work into investigating or tweaking its performance.  I suspect there would be some relatively low-hanging fruit that could help close this gap.</p>

<p>Faster still is the native python interpreter that came with my system, CPython 2.7.4.  This is an important point that sometimes gets forgotten: without its JIT, the PyPy interpreter can often be slower than the standard python interpreter.  That's currently the price it pays for the flexibility of its implementation, but things need not stay that way &ndash; the PyPy developers are always on the lookout for ways to speed up the interpreter even in the absence of its JIT.</p>

<p>Unsurprisingly, the speed king is a native build of PyPy with its JIT features enabled.</p>

<p>It would be easy to look at the two-orders-of-magnitude difference here &ndash; 7427 for pypy.js compared to 781250 for native pypy &ndash; and think that thr javascript version is a bit of a bust.  But this is just a first attempt, and the javascript version was running without the benefit of PyPy's special speed sauce.  If we could successfully translate PyPy's JIT functionality into javascript, we should be able to claw back a large chunk of that performance gap.  It's a <i><b>big</b></i> if, but an interesting possibility.</p>

<p>As a preview of what might be possible, consider the <a href="https://github.com/rfk/pypy/blob/master/rpython/translator/test/rpystone.py">stand-alone rpython version of pystone</a> that's available in the PyPy repo.  If we compile that from rpython down to native code, it will give us a rough upper limit on the capabilities of the machine.  And if we compile that from rpython down to javascript, it will give us a rough upper limit on what the possibilities of a jit-enabled-pypy-in-javascript might be:

<table>
<tr><th>Interpreter</th><th>Pystones/sec</th></tr>
<tr><td>native rpystone</td><td>38461538</td></tr>
<tr><td>rpystone.js, on spidermonkey</td><td>13531802</td></tr>
</table>

<p>Compared to the interpreter results above, these numbers are astonishingly high.  So much so that I suspect they're not entirely accurate, and are being skewed by some difference between the rpython version of pystone and the standard one.  But that's not really the point anyway.</p>

<p>The interesting thing here is the comparative performance of the two versions.  The javascript version is  less than three times slower than the natively-compiled version, a much smaller gap than what we saw with the full interpreter.  Could a javascript JIT backend produce code that's only three times slower than that produces by the native JIT backend?  This test gives a glimmer of hope.</p>

<h3>Will it JIT?</h3>

<p>Is javascript-the-platform powerful enough to support PyPy's JIT features?  Frankly, I've no idea!  But it's my ongoing mission to dig more into the details of the rpython JIT generator and figure out what an asm.js backend might look like.  I'm recording some initial thoughts here, and hoping it might spur some discussion and good idea from the communities on both sides.</p>

<p>From the javascript side, there is one very positive note: the <a href="http://asmjs.org">asm.js specification</a> explicitly calls out the possibility of generating and linking new asm.js modules at any state during the running of your code.  It is fully supported and fully expected, given the dynamic nature of javascript.</p>

<p>However, asm.js code itself is forbidden from creating new functions.  For the compiled PyPy interpreter to JIT-compile some code, it would have to move out of the asm.js "fast path" by invoking an external javascript function.  To actually <i>call</i> the generated code, it would likewise need to invoke an external trampoline to escape out of its own asm.js module and call into the new one.  The JITed code would need a similar trampoline to call back into the main interpreter.</p>

<p>This kind of <a href="https://github.com/kripken/emscripten/wiki/Linking">inter-asmjs-module linking</a> is a tentative item on the emscripten roadmap, but it's not clear how much overhead it would entail.  If the cost of all this jumping back-and-forth were too high, it could easily swamp any performance benefit that the JITed code might bring.</p>

<p>There are also some potential roadblocks on the PyPy side.  The PyPy developers tried several times to use LLVM as their JIT backend, but <a href="https://rpython.readthedocs.org/en/improve-docs/faq.html#could-we-use-llvm">repeatedly found it unsuitable</a>.  One of the main reasons cited was an inability to dynamically patch the generated machine code, a weakness that would be shared by a javascript JIT backend.</p>

<p>It's not yet clear to me exactly how limiting this will be.  If it's something that can be worked around at the cost of some efficiency, e.g. by adding additional checks and flag variables into the generated code, then it's possible that we can still extract enough performance for a JIT to add value.  But if this kind of dynamic code-patching is fundamental to the operation of the JIT then we may be out of luck.</p>

<p>Ultimately, we'll have to try it and see.  Assuming I can find the time, I plan to give it a shot.</p>

<p>PyPy with JIT is often reported to be six or more times faster than CPython on some benchmarks.  And we've seen that asm.js code can run at less than three times slower than native code.  So here's my lofty, crazy, good-for-motivation-but-likely-futile goal:  pypy.js, running in the spidermonkey shell, getting more pystones per second than the native cpython interpreter.</p>

<p>Possible?  Frankly, I've no idea.  But it's going to be fun finding out.</p>
