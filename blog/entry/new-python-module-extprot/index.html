<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta charset="utf-8">
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />

    <meta property="og:type" content="website">
    <meta property="og:url" content="https:&#x2F;&#x2F;www.rfk.id.au&#x2F;blog&#x2F;entry&#x2F;new-python-module-extprot&#x2F;" />

    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@rfkelly">
    <meta name="twitter:site" content="@rfkelly">

    
      <meta name="twitter:title" content="New Python module: extprot">
      <title>New Python module: extprot</title>
    
    
    
    <link rel="icon" href="https:&#x2F;&#x2F;www.rfk.id.au&#x2F;processed_images&#x2F;92fe386560fb112700.png" />
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira Sans|Fira Mono">
    <link rel="stylesheet" href="https://www.rfk.id.au/main.css">
     
  </head>
  <body>
    
      <header>
        <a class="profile-icon" href="/">
          
          <img src="https:&#x2F;&#x2F;www.rfk.id.au&#x2F;processed_images&#x2F;92fe386560fb112700.png" alt="profile picture">
        </a>
        <nav>
            <a href="/about/">About</a>
            <a href="/blog/">Blog</a>
            <a href="https://github.com/rfk">GitHub</a>
            <a href="https://twitter.com/rfkelly">Twitter</a>
        </nav>
      </header>
    
    <main>
    
  <h1>New Python module: extprot</h1>
  <div class="item-meta">
    
    <div class="item-date">August 04, 2009</div>
    
      <div class="item-tags">
        [ 
        
          <a href="https://www.rfk.id.au/tags/software/">software</a>
           | 
        
          <a href="https://www.rfk.id.au/tags/python/">python</a>
          
        
        ]
      </div>
    
    
  </div>

  <p>One of my commercial projects requires a space-efficient object serialisation format, and until now I've been using the obvious choice in Google's <a href="http://code.google.com/p/protobuf/">Protocol Buffers</a>.  I'm happy enough with the format itself, but the experience of using the Python bindings was just barely satisfactory.  The interface feels quite Java-ish and there are some non-obvious gotchas, such as having to use special methods to manipulate list fields.  I ploughed ahead, but was quietly looking around for alternatives.</p>
<p>The last straw came when I tried to establish a deployment scheme using <a href="http://blog.ianbicking.org/2008/12/16/using-pip-requirements/">pip requirements files</a>.  Both <code>pip install protobuf</code> and <code>easy_install protobuf</code> fail hard: the pypi eggs are out of date, the source download has a non-standard structure, and the <code>setup.py</code> script tries to bootstrap itself using the protobuf compiler that it assumes you have already built.  Yuck.  This was more pain than I was willing to put up with.  Plus it was a good opportunity to take another look around.</p>
<span id="continue-reading"></span>
<p>I toyed briefly with <a href="http://developers.facebook.com/thrift/">Facebook's</a>...errr...I mean <a href="http://developers.facebook.com/thrift/">Apache Thrift</a>, but it had too much remote-procedure-call baggage and not enough documentation.  Then I stumbled across a great little screed about <a href="http://eigenclass.org/R2/writings/extprot-extensible-protocols-intro">extprot</a>, a technology to create &quot;compact, efficient and extensible binary protocols that can be used for cross-language communication and long-term data serialization&quot;.</p>
<p>Yet another wire format for data serialisation?  Yes, but this one has some neat features that fit well into my headspace:</p>
<ul>
<li>a <strong>powerful type system</strong>; This inludes strongly-typed tuples and lists, tagged disjoint unions, and parametric polymorphism in the style of Haskell or ML.  Once you've used a disjoint union type, you will never want to see another enum as long as you live.</li>
<li><strong>self-describing data</strong>; The 'skeleton' of a message can be recovered without knowing the protocol definition.  This is approximately like reading an XML document without knowing anything about the tag names.</li>
<li><strong>self-delimiting data</strong>; All serialised messages indicate their length, allowing easy streaming and skipping of individual protocol components.  Entirely new wire types can thus be added without breaking existing parsers.</li>
</ul>
<p>These features combine to make extprot strongly extensible. Messages can often maintain backward <em>and</em> forward compatibility across protocol extensions that include adding fields to a message, adding elements to a tuple, adding cases to a disjoint union, and promoting a primitive type into
a tuple, list or union.</p>
<p>There's just one problem of course â€“ no Python bindings.  But as they say, every problem is an opportunity in disguise.</p>
<p>The module's called &quot;extprot&quot;, the packages are on <a href="http://pypi.python.org/pypi/extprot/">pypi</a>, and the code is on <a href="http://github.com/rfk/extprot/tree/master">github</a>.  It was a remarkably fun experience trying to reify a Hindley-Milner-style type system as Python class objects, and I'm quite happy with the way it turned out.  As an added bonus I got to try out the fabulous <a href="http://pyparsing.wikispaces.com/">pyparsing</a> module for the first time.  In the author's humble opinion, this extprot package has got some serious advantages over the protobuf python bindings:</p>
<ul>
<li>It's a pure-python module, packaged and distributed in the standard fashion.</li>
<li>It's friendly to dynamic package management tools like pip.</li>
<li>It works exclusively with standard Python objects.  Declared a list field?  It's a native list object.</li>
<li>You don't need to compile your protocol definitions.</li>
</ul>
<p>That last point deserves a special mention.  Dammit, <em><strong>this is Python!</strong></em>  I don't want to introduce a compiler into my fantastically productive read-eval-print loop.  With extprot, you can point the module to your protocol definition file and dynamically compile it into an in-memory class structure.  Suppose I have the following protocol definition file:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>    message person = {
</span><span>        id:   int;
</span><span>        name: string;
</span><span>        emails: [ string ]
</span><span>    }
</span></code></pre>
<p>I can load and use it in python with this much work:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">import </span><span>extprot
</span><span>&gt;&gt;&gt; extprot.</span><span style="color:#bf616a;">import_protocol</span><span>(&quot;</span><span style="color:#a3be8c;">mydefs.proto</span><span>&quot;,</span><span style="color:#96b5b4;">globals</span><span>())
</span><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">print </span><span>person
</span><span>&lt;</span><span style="background-color:#bf616a;color:#2b303b;">class</span><span> &#39;</span><span style="color:#a3be8c;">&lt;extprot.dynamic&gt;.person</span><span>&#39;&gt;
</span></code></pre>
<p>And I can work with the resulting classes without any knowledge of extprot:</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span>&gt;&gt;&gt; p1 = </span><span style="color:#bf616a;">person</span><span>(</span><span style="color:#d08770;">1</span><span>,&quot;</span><span style="color:#a3be8c;">Guido</span><span>&quot;)    </span><span style="color:#65737e;"># kwd args would also work
</span><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">print </span><span>p1.emails    </span><span style="color:#65737e;"># fields use a sensible default if possible
</span><span>[]
</span><span>&gt;&gt;&gt; p1.emails.</span><span style="color:#bf616a;">append</span><span>(&quot;</span><span style="color:#a3be8c;">guido@python.org</span><span>&quot;)
</span><span>&gt;&gt;&gt; p1.emails.</span><span style="color:#bf616a;">append</span><span>(</span><span style="color:#d08770;">7</span><span>)    </span><span style="color:#65737e;"># all fields are dynamically typechecked
</span><span style="color:#bf616a;">Traceback </span><span>(mosts recent call last):
</span><span>    </span><span style="color:#d08770;">...
</span><span>ValueError: not a valid String: </span><span style="color:#d08770;">7
</span><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">print </span><span style="color:#96b5b4;">repr</span><span>(p1.</span><span style="color:#bf616a;">to_string</span><span>())    </span><span style="color:#65737e;"># look at that compact binary string!
</span><span>&#39;</span><span style="color:#96b5b4;">\x01\x1f\x03\x00\x02\x03\x05</span><span style="color:#a3be8c;">Guido</span><span style="color:#96b5b4;">\x05\x13\x01\x03\x10</span><span style="color:#a3be8c;">guido@python.org</span><span>&#39;
</span><span>&gt;&gt;&gt; </span><span style="color:#b48ead;">print </span><span>person.</span><span style="color:#bf616a;">from_string</span><span>(p1.</span><span style="color:#bf616a;">to_string</span><span>()).name
</span><span>&#39;</span><span style="color:#a3be8c;">Guido</span><span>&#39;
</span></code></pre>
<p>Now it's time to fess up just a little: the size of the encodings produced by extprot are of the same order as those from protobuf, but they do have a few extra bytes of overhead due to their self-delimiting nature.  For my applications these extra bytes don't outweigh the advantages I've described above, but your mileage may vary.  I also suspect it would be trivial to remove these delimiters in a separate translation step if you really needed to squeeze them out.</p>
<p>So, looking for a language-neutral serialisation or messaging scheme?  Take a look at <a href="http://eigenclass.org/R2/writings/extprot-extensible-protocols-intro">extprot</a>, its very powerful <a href="http://github.com/mfp/extprot/blob/38ef5d4d9c6d206943ef96abf1e36a01f5578176/doc/protocol-definition.md">type system</a> and the flexible <a href="http://eigenclass.org/R2/writings/protocol-extension-with-extprot">protocol extensions</a> that it permits.  In my opinion it's a serious contender, and I hope these Python bindings help push it along  just a little.</p>


  <hr />

  <div class="related-pages">
    <div><a href="https:&#x2F;&#x2F;www.rfk.id.au&#x2F;blog&#x2F;entry&#x2F;announcing-django-paranoid-sessions&#x2F;">Announcing: django-paranoid-sessions</a></div>
    <div><a href="https:&#x2F;&#x2F;www.rfk.id.au&#x2F;blog&#x2F;entry&#x2F;lachlan-and-aidan-welcome&#x2F;">Lachlan and Aidan</a></div>
  </div>

    </main>
  </body>
</html>